use std::path::PathBuf;
use std::sync::Arc;
use std::time::Duration;

use crate::host::{Host, HostApi, HostConfig};
use crate::oci::{self, OciConfig};
use crate::plugin::HostPlugin;
use anyhow::Context as _;
use futures::StreamExt as _;
use tokio::sync::oneshot;
use tracing::{debug, error, info, instrument};

pub const HOST_API_PREFIX: &str = "runtime.host";
pub const OPERATOR_API_PREFIX: &str = "runtime.operator";
const HEARTBEAT_INTERVAL: Duration = Duration::from_secs(15);

pub mod types {
    pub mod v2 {
        // Generated by [`tonic-build`]
        include!(concat!(env!("OUT_DIR"), "/wasmcloud.runtime.v2.rs"));
        // Generated by [`pbjson-build`]
        include!(concat!(env!("OUT_DIR"), "/wasmcloud.runtime.v2.serde.rs"));
    }
}

#[derive(Default)]
pub struct ClusterHostBuilder {
    host_builder: crate::host::HostBuilder,
    nats_client: Option<Arc<async_nats::Client>>,
    host_group: Option<String>,
    host_name: Option<String>,
    heartbeat_interval: Option<Duration>,
    host_config: Option<HostConfig>,
}

impl ClusterHostBuilder {
    pub fn with_host_group(mut self, host_group: impl AsRef<str>) -> Self {
        self.host_group = Some(host_group.as_ref().into());
        self
    }

    pub fn with_host_name(mut self, host_name: impl AsRef<str>) -> Self {
        self.host_name = Some(host_name.as_ref().into());
        self
    }

    pub fn with_host_config(mut self, host_config: HostConfig) -> Self {
        self.host_config = Some(host_config);
        self
    }

    pub fn with_host_builder(mut self, host_builder: crate::host::HostBuilder) -> Self {
        self.host_builder = host_builder;
        self
    }

    pub fn with_nats_client(mut self, nats_client: Arc<async_nats::Client>) -> Self {
        self.nats_client = Some(nats_client);
        self
    }

    pub fn with_plugin<T: HostPlugin>(mut self, plugin: Arc<T>) -> anyhow::Result<Self> {
        self.host_builder = self.host_builder.with_plugin(plugin)?;
        Ok(self)
    }

    pub fn with_http_handler(
        mut self,
        http_handler: Arc<dyn crate::host::http::HostHandler>,
    ) -> Self {
        self.host_builder = self.host_builder.with_http_handler(http_handler);
        self
    }

    pub fn build(self) -> anyhow::Result<ClusterHost> {
        let Some(nats_client) = self.nats_client else {
            anyhow::bail!("nats_client is required");
        };
        let Some(host_group) = self.host_group else {
            anyhow::bail!("host_group is required");
        };

        let mut builder = self
            .host_builder
            .with_label("hostgroup", host_group.clone());

        if let Some(host_name) = self.host_name {
            builder = builder.with_hostname(host_name)
        }

        if let Some(host_config) = self.host_config {
            builder = builder.with_config(host_config);
        }

        let heartbeat_interval = self.heartbeat_interval.unwrap_or(HEARTBEAT_INTERVAL);
        let host = builder.build()?;
        Ok(ClusterHost {
            prepared_host: host,
            nats_client,
            heartbeat_interval,
        })
    }
}

pub struct ClusterHost {
    prepared_host: Host,
    nats_client: Arc<async_nats::Client>,
    heartbeat_interval: Duration,
}

impl ClusterHost {
    pub fn host(&self) -> &Host {
        &self.prepared_host
    }
}

pub async fn run_cluster_host(
    cluster_host: ClusterHost,
) -> anyhow::Result<impl Future<Output = anyhow::Result<()>>, anyhow::Error> {
    let (one_shot_tx, mut one_shot_rx) = oneshot::channel();
    let nats_client = cluster_host.nats_client.clone();
    let host = cluster_host
        .prepared_host
        .start()
        .await
        .context("failed to start host")?;

    let heartbeat_interval = cluster_host.heartbeat_interval;
    let host_id = host.id().to_string();
    let host = host.clone();

    info!(
        host_id=?host_id,
        friendly_name=?host.friendly_name(),
        host_name=?host.hostname(),
        labels=?host.labels(),
        version=?host.version(),
        "Host started");

    host.log_interfaces();

    let task = tokio::task::spawn(async move {
        let host_subject = host_subject(host_id.as_ref());

        let heartbeat_subject = heartbeat_subject(host_id.as_ref());

        let mut api_subscription = nats_client
            .subscribe(host_subject)
            .await
            .context("failed to subscribe for API requests")?;
        let mut heartbeat_timer = tokio::time::interval(heartbeat_interval);

        let mut oci_cleanup_timer = tokio::time::interval(Duration::from_secs(300));

        loop {
            tokio::select! {
                // Shutdown signal
                _ = &mut one_shot_rx => {
                    api_subscription.unsubscribe().await.context("failed to unsubscribe from API requests")?;
                    return host.stop().await.context("failed to stop host");
                }
                // OCI cache cleanup
                _ = oci_cleanup_timer.tick() => {
                    if let Some(cache_dir) = host.config().oci_cache_dir.as_ref() &&
                    let Err(e) = oci::cleanup_cache(cache_dir, Duration::from_hours(1)).await {
                        error!("Error during OCI cache cleanup: {}", e);
                    }
                }
                // Send heartbeat
                _ = heartbeat_timer.tick() => {
                    let heartbeat = host_heartbeat(&host).await?;
                    let heartbeat_bytes = serde_json::to_vec(&heartbeat)
                        .context("failed to serialize heartbeat")?;
                    nats_client.publish(heartbeat_subject.clone(), heartbeat_bytes.into()).await.context("failed to publish heartbeat")?;
                }
                // Handle API requests
                Some(msg) = api_subscription.next() => {
                    let response = handle_command(host.as_ref(), &msg, host.config()).await;
                    match response {
                        Ok(resp_bytes) => {
                            if let Some(reply_to) = msg.reply {
                                nats_client.publish(reply_to, resp_bytes.into()).await.context("failed to publish API response")?;
                            }
                        }
                        Err(e) => {
                            eprintln!("Error handling command: {}", e);
                        }
                    }
                }
            }
        }
    });

    Ok(async move {
        let _ = one_shot_tx.send(());
        task.await?
    })
}

/// Configuration options for NATS connections
#[derive(Debug, Clone, Default)]
pub struct NatsConnectionOptions {
    /// Request timeout for NATS operations
    pub request_timeout: Option<Duration>,
    /// Path to TLS CA certificate file for NATS connection
    pub tls_ca: Option<PathBuf>,
    /// Enable TLS handshake first mode for NATS connection
    pub tls_first: bool,
    /// Path to NATS TLS certificate file
    pub tls_cert: Option<PathBuf>,
    /// Path to NATS TLS private key file
    pub tls_key: Option<PathBuf>,
}

#[instrument(skip_all)]
pub async fn connect_nats(
    addr: impl async_nats::ToServerAddrs,
    options: NatsConnectionOptions,
) -> Result<async_nats::Client, anyhow::Error> {
    let mut opts = async_nats::ConnectOptions::new();

    if let Some(timeout) = options.request_timeout {
        opts = opts.request_timeout(Some(timeout));
    }

    if let Some(ca_path) = options.tls_ca {
        opts = opts.add_root_certificates(ca_path)
    }

    if options.tls_first {
        opts = opts.tls_first();
    }

    if let (Some(cert_path), Some(key_path)) = (options.tls_cert, options.tls_key) {
        opts = opts.add_client_certificate(cert_path, key_path)
    }

    opts.connect(addr)
        .await
        .context("failed to connect to NATS")
}

pub fn host_subject(host_id: &str) -> String {
    format!("{HOST_API_PREFIX}.{host_id}.>")
}

pub fn rpc_subject(host_id: &str, command: &str) -> String {
    format!("{HOST_API_PREFIX}.{host_id}.{command}")
}

pub fn heartbeat_subject(host_id: &str) -> String {
    format!("{OPERATOR_API_PREFIX}.heartbeat.{host_id}")
}

/// Helper function to serialize a message to the API format.
fn to_api<T: prost::Message + serde::Serialize>(msg: &T) -> Result<Vec<u8>, anyhow::Error> {
    serde_json::to_vec_pretty(msg).map_err(anyhow::Error::new)
}

/// Helper function to deserialize a message from the API format.
fn from_api<'de, T: serde::Deserialize<'de>>(bytes: &'de [u8]) -> Result<T, anyhow::Error> {
    serde_json::from_slice(bytes).map_err(anyhow::Error::new)
}

#[instrument(level = "debug", skip_all, fields(subject = %msg.subject))]
async fn handle_command(
    host: &impl HostApi,
    msg: &async_nats::Message,
    config: &HostConfig,
) -> Result<Vec<u8>, anyhow::Error> {
    let command = msg.subject.split('.').skip(3).collect::<Vec<_>>().join(".");

    let payload = &msg.payload;

    match command.as_str() {
        "heartbeat" => {
            let res = host_heartbeat(host).await?;
            to_api(&res)
        }
        "workload.start" => {
            let req: types::v2::WorkloadStartRequest = from_api(payload)?;
            let res = workload_start(host, req, config).await?;
            to_api(&res)
        }
        "workload.stop" => {
            let req: types::v2::WorkloadStopRequest = from_api(payload)?;
            let res = workload_stop(host, req).await?;
            to_api(&res)
        }
        "workload.status" => {
            let req: types::v2::WorkloadStatusRequest = from_api(payload)?;
            let res = workload_status(host, req).await?;
            to_api(&res)
        }
        // catch-all
        _ => anyhow::bail!("unknown command: {command}"),
    }
}

/// Convert ImagePullSecret from protobuf to OciConfig
fn image_pull_secret_to_oci_config(
    config: &HostConfig,
    pull_secret: &Option<types::v2::ImagePullSecret>,
) -> oci::OciConfig {
    let mut oci_config = match &pull_secret {
        Some(creds) => oci::OciConfig::new_with_credentials(&creds.username, &creds.password),
        None => OciConfig::default(),
    };
    oci_config.cache_dir = config.oci_cache_dir.clone();
    oci_config.insecure = config.allow_oci_insecure;
    oci_config.timeout = config.oci_pull_timeout;

    oci_config
}

#[instrument(level = "debug", skip_all)]
async fn host_heartbeat(host: &impl HostApi) -> anyhow::Result<types::v2::HostHeartbeat> {
    let hb = host.heartbeat().await?;

    Ok(hb.into())
}

#[instrument(skip_all, fields(
    workload_id = %req.workload_id,
    workload.name=?req.workload.as_ref().map(|w| &w.name).unwrap_or(&"<none>".to_string()),
    workload.namespace=?req.workload.as_ref().map(|w| &w.namespace).unwrap_or(&"<none>".to_string())),
    )]
async fn workload_start(
    host: &impl HostApi,
    req: types::v2::WorkloadStartRequest,
    config: &HostConfig,
) -> anyhow::Result<types::v2::WorkloadStartResponse> {
    let Some(types::v2::Workload {
        namespace,
        name,
        annotations,
        service,
        wit_world,
        volumes,
    }) = req.workload
    else {
        anyhow::bail!("workload is required");
    };

    let workload_id = req.workload_id.clone();
    if workload_id.is_empty() {
        anyhow::bail!("workload_id is required");
    }

    let (components, host_interfaces) = if let Some(wit_world) = wit_world {
        let mut pulled_components = Vec::with_capacity(wit_world.components.len());
        for component in &wit_world.components {
            let oci_config = image_pull_secret_to_oci_config(config, &component.image_pull_secret);
            let (bytes, digest) = match oci::pull_component(
                &component.image,
                oci_config,
                component.image_pull_policy().into(),
            )
            .await
            {
                Ok(res) => res,
                Err(e) => {
                    return Ok(types::v2::WorkloadStartResponse {
                        workload_status: Some(types::v2::WorkloadStatus {
                            workload_id: workload_id.clone(),
                            workload_state: types::v2::WorkloadState::Error.into(),
                            message: format!(
                                "failed to pull component image {}: {}",
                                component.image, e
                            ),
                        }),
                    });
                }
            };
            pulled_components.push(crate::types::Component {
                name: component.name.clone(),
                bytes: bytes.into(),
                digest: Some(digest),
                local_resources: component
                    .local_resources
                    .clone()
                    .map(Into::into)
                    .unwrap_or_default(),
                pool_size: component.pool_size,
                max_invocations: component.max_invocations,
            })
        }
        (
            pulled_components,
            wit_world
                .host_interfaces
                .into_iter()
                .map(Into::into)
                .collect(),
        )
    } else {
        (vec![], vec![])
    };

    let service = if let Some(service) = service {
        let oci_config = image_pull_secret_to_oci_config(config, &service.image_pull_secret);
        let (bytes, digest) = match oci::pull_component(
            &service.image,
            oci_config,
            service.image_pull_policy().into(),
        )
        .await
        {
            Ok(res) => res,
            Err(e) => {
                return Ok(types::v2::WorkloadStartResponse {
                    workload_status: Some(types::v2::WorkloadStatus {
                        workload_id: workload_id.clone(),
                        workload_state: types::v2::WorkloadState::Error.into(),
                        message: format!("failed to pull service image {}: {}", service.image, e),
                    }),
                });
            }
        };
        Some(crate::types::Service {
            bytes: bytes.into(),
            digest: Some(digest),
            local_resources: service
                .local_resources
                .clone()
                .map(Into::into)
                .unwrap_or_default(),
            max_restarts: service.max_restarts,
        })
    } else {
        None
    };

    let volumes = volumes.into_iter().map(Into::into).collect();

    let request = crate::types::WorkloadStartRequest {
        workload_id: workload_id.clone(),
        workload: crate::types::Workload {
            namespace,
            name,
            annotations,
            service,
            components,
            host_interfaces,
            volumes,
        },
    };

    info!(
        worload_id=?workload_id,
        namespace=?request.workload.namespace,
        name=?request.workload.name,
        "Starting workload");

    Ok(host.workload_start(request).await?.into())
}

#[instrument(skip_all, fields(workload_id = %req.workload_id))]
async fn workload_stop(
    host: &impl HostApi,
    req: types::v2::WorkloadStopRequest,
) -> anyhow::Result<types::v2::WorkloadStopResponse> {
    info!(
        worload_id=?req.workload_id,
        "Stopping workload");

    host.workload_stop(req.into()).await.map(|resp| resp.into())
}

#[instrument(skip_all, fields(workload_id = %req.workload_id))]
async fn workload_status(
    host: &impl HostApi,
    req: types::v2::WorkloadStatusRequest,
) -> anyhow::Result<types::v2::WorkloadStatusResponse> {
    debug!(
        worload_id=?req.workload_id,
        "Fetching workload status");

    host.workload_status(req.into())
        .await
        .map(|resp| resp.into())
}

impl From<types::v2::WitInterface> for crate::wit::WitInterface {
    fn from(wi: types::v2::WitInterface) -> Self {
        crate::wit::WitInterface {
            namespace: wi.namespace,
            package: wi.package,
            version: if wi.version.is_empty() {
                None
            } else {
                wi.version.parse::<semver::Version>().ok()
            },
            interfaces: wi.interfaces.into_iter().collect(),
            config: wi.config,
        }
    }
}
impl From<types::v2::VolumeMount> for crate::types::VolumeMount {
    fn from(vm: types::v2::VolumeMount) -> Self {
        crate::types::VolumeMount {
            name: vm.name,
            mount_path: vm.mount_path,
            read_only: vm.read_only,
        }
    }
}

impl From<types::v2::Volume> for crate::types::Volume {
    fn from(v: types::v2::Volume) -> Self {
        crate::types::Volume {
            name: v.name,
            volume_type: match v.volume_type {
                Some(vt) => match vt {
                    types::v2::volume::VolumeType::HostPath(hp) => {
                        crate::types::VolumeType::HostPath(crate::types::HostPathVolume {
                            local_path: hp.local_path,
                        })
                    }
                    types::v2::volume::VolumeType::EmptyDir(_) => {
                        crate::types::VolumeType::EmptyDir(crate::types::EmptyDirVolume {})
                    }
                },
                None => crate::types::VolumeType::EmptyDir(crate::types::EmptyDirVolume {}),
            },
        }
    }
}

impl From<types::v2::LocalResources> for crate::types::LocalResources {
    fn from(lr: types::v2::LocalResources) -> Self {
        crate::types::LocalResources {
            memory_limit_mb: lr.memory_limit_mb,
            cpu_limit: lr.cpu_limit,
            config: lr.config,
            volume_mounts: lr.volume_mounts.into_iter().map(Into::into).collect(),
            allowed_hosts: lr.allowed_hosts,
            environment: lr.environment,
        }
    }
}

impl From<crate::types::HostHeartbeat> for types::v2::HostHeartbeat {
    fn from(hb: crate::types::HostHeartbeat) -> Self {
        types::v2::HostHeartbeat {
            id: hb.id,
            hostname: hb.hostname,
            version: hb.version,
            started_at: Some(hb.started_at.into()),
            imports: hb.imports.into_iter().map(Into::into).collect(),
            exports: hb.exports.into_iter().map(Into::into).collect(),
            os_name: hb.os_name,
            os_arch: hb.os_arch,
            os_kernel: hb.os_kernel,
            system_cpu_usage: hb.system_cpu_usage,
            component_count: hb.component_count,
            workload_count: hb.workload_count,
            system_memory_total: hb.system_memory_total,
            system_memory_free: hb.system_memory_free,
            labels: hb.labels,
            friendly_name: hb.friendly_name,
            http_port: hb.http_port.into(),
        }
    }
}

impl From<crate::wit::WitInterface> for types::v2::WitInterface {
    fn from(wi: crate::wit::WitInterface) -> Self {
        types::v2::WitInterface {
            namespace: wi.namespace,
            package: wi.package,
            version: wi.version.map(|v| v.to_string()).unwrap_or_default(),
            interfaces: wi.interfaces.into_iter().collect(),
            config: wi.config,
        }
    }
}

// Conversions from API v2 request types to runtime::host types

impl From<types::v2::WorkloadStopRequest> for crate::types::WorkloadStopRequest {
    fn from(req: types::v2::WorkloadStopRequest) -> Self {
        crate::types::WorkloadStopRequest {
            workload_id: req.workload_id,
        }
    }
}

impl From<types::v2::WorkloadStatusRequest> for crate::types::WorkloadStatusRequest {
    fn from(req: types::v2::WorkloadStatusRequest) -> Self {
        crate::types::WorkloadStatusRequest {
            workload_id: req.workload_id,
        }
    }
}

// Conversions from runtime::host response types to API v2 types

impl From<crate::types::WorkloadStartResponse> for types::v2::WorkloadStartResponse {
    fn from(resp: crate::types::WorkloadStartResponse) -> Self {
        types::v2::WorkloadStartResponse {
            workload_status: Some(resp.workload_status.into()),
        }
    }
}

impl From<crate::types::WorkloadStopResponse> for types::v2::WorkloadStopResponse {
    fn from(resp: crate::types::WorkloadStopResponse) -> Self {
        types::v2::WorkloadStopResponse {
            workload_status: Some(resp.workload_status.into()),
        }
    }
}

impl From<crate::types::WorkloadStatusResponse> for types::v2::WorkloadStatusResponse {
    fn from(resp: crate::types::WorkloadStatusResponse) -> Self {
        types::v2::WorkloadStatusResponse {
            workload_status: Some(resp.workload_status.into()),
        }
    }
}

impl From<crate::types::WorkloadStatus> for types::v2::WorkloadStatus {
    fn from(status: crate::types::WorkloadStatus) -> Self {
        types::v2::WorkloadStatus {
            workload_id: status.workload_id,
            workload_state: status.workload_state as i32,
            message: status.message,
        }
    }
}

impl From<types::v2::ImagePullPolicy> for crate::oci::OciPullPolicy {
    fn from(policy: types::v2::ImagePullPolicy) -> Self {
        match policy {
            types::v2::ImagePullPolicy::Always => crate::oci::OciPullPolicy::Always,
            types::v2::ImagePullPolicy::IfNotPresent => crate::oci::OciPullPolicy::IfNotPresent,
            types::v2::ImagePullPolicy::Never => crate::oci::OciPullPolicy::Never,
            _ => crate::oci::OciPullPolicy::IfNotPresent,
        }
    }
}

#[cfg(test)]
mod tests {

    use super::*;

    #[tokio::test]
    async fn test_image_pull_secret_to_oci_config_none() {
        let host_config = HostConfig {
            allow_oci_insecure: false,
            ..Default::default()
        };
        let secret: Option<types::v2::ImagePullSecret> = None;
        let config = image_pull_secret_to_oci_config(&host_config, &secret);
        assert!(config.credentials.is_none());
        assert!(!config.insecure);
    }

    #[tokio::test]
    async fn test_image_pull_secret_to_oci_config_basic_auth() {
        let secret = Some(types::v2::ImagePullSecret {
            username: "testuser".to_string(),
            password: "testpass".to_string(),
        });

        let host_config = HostConfig {
            allow_oci_insecure: false,
            ..Default::default()
        };
        let config = image_pull_secret_to_oci_config(&host_config, &secret);
        assert_eq!(
            config.credentials,
            Some(("testuser".to_string(), "testpass".to_string()))
        );
    }
}
