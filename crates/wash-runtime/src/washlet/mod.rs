use std::path::PathBuf;
use std::sync::Arc;
use std::time::Duration;

use crate::host::{Host, HostApi, HostConfig};
use crate::oci::{self, OciConfig};
use crate::plugin::HostPlugin;
use anyhow::Context as _;
use futures::StreamExt as _;
use opentelemetry::KeyValue;
use opentelemetry_sdk::resource::{Resource, ResourceBuilder};
use opentelemetry_semantic_conventions::resource;
use sysinfo::System;
use tokio::sync::oneshot;
use tracing::{debug, info};

pub mod plugins;

pub const HOST_API_PREFIX: &str = "runtime.host";
pub const OPERATOR_API_PREFIX: &str = "runtime.operator";
const HEARTBEAT_INTERVAL: Duration = Duration::from_secs(15);

pub mod types {
    pub mod v2 {
        // Generated by [`tonic-build`]
        include!(concat!(env!("OUT_DIR"), "/wasmcloud.runtime.v2.rs"));
        // Generated by [`pbjson-build`]
        include!(concat!(env!("OUT_DIR"), "/wasmcloud.runtime.v2.serde.rs"));
    }
}

#[derive(Default)]
pub struct ClusterHostBuilder {
    host_builder: crate::host::HostBuilder,
    nats_client: Option<Arc<async_nats::Client>>,
    host_group: Option<String>,
    host_name: Option<String>,
    heartbeat_interval: Option<Duration>,
    host_config: Option<HostConfig>,
}

impl ClusterHostBuilder {
    pub fn with_host_group(mut self, host_group: impl AsRef<str>) -> Self {
        self.host_group = Some(host_group.as_ref().into());
        self
    }

    pub fn with_host_name(mut self, host_name: impl AsRef<str>) -> Self {
        self.host_name = Some(host_name.as_ref().into());
        self
    }

    pub fn with_host_config(mut self, host_config: HostConfig) -> Self {
        self.host_config = Some(host_config);
        self
    }

    pub fn with_host_builder(mut self, host_builder: crate::host::HostBuilder) -> Self {
        self.host_builder = host_builder;
        self
    }

    pub fn with_nats_client(mut self, nats_client: Arc<async_nats::Client>) -> Self {
        self.nats_client = Some(nats_client);
        self
    }

    pub fn with_plugin<T: HostPlugin>(mut self, plugin: Arc<T>) -> anyhow::Result<Self> {
        self.host_builder = self.host_builder.with_plugin(plugin)?;
        Ok(self)
    }

    pub fn with_http_handler(
        mut self,
        http_handler: Arc<dyn crate::host::http::HostHandler>,
    ) -> Self {
        self.host_builder = self.host_builder.with_http_handler(http_handler);
        self
    }

    pub fn build(self) -> anyhow::Result<ClusterHost> {
        let Some(nats_client) = self.nats_client else {
            anyhow::bail!("nats_client is required");
        };
        let Some(host_group) = self.host_group else {
            anyhow::bail!("host_group is required");
        };

        let mut builder = self
            .host_builder
            .with_label("hostgroup", host_group.clone());

        if let Some(host_name) = self.host_name {
            builder = builder.with_hostname(host_name)
        }

        if let Some(host_config) = self.host_config {
            builder = builder.with_config(host_config);
        }

        let heartbeat_interval = self.heartbeat_interval.unwrap_or(HEARTBEAT_INTERVAL);
        let host = builder.build()?;
        Ok(ClusterHost {
            prepared_host: host,
            nats_client,
            heartbeat_interval,
        })
    }
}

pub struct ClusterHost {
    prepared_host: Host,
    nats_client: Arc<async_nats::Client>,
    heartbeat_interval: Duration,
}

impl ClusterHost {
    pub fn host(&self) -> &Host {
        &self.prepared_host
    }
}

pub async fn run_cluster_host(
    cluster_host: ClusterHost,
) -> anyhow::Result<impl Future<Output = anyhow::Result<()>>, anyhow::Error> {
    let (one_shot_tx, mut one_shot_rx) = oneshot::channel();
    let nats_client = cluster_host.nats_client.clone();
    let host = cluster_host
        .prepared_host
        .start()
        .await
        .context("failed to start host")?;

    let heartbeat_interval = cluster_host.heartbeat_interval;
    let host_id = host.id().to_string();
    let host = host.clone();

    info!(
        host_id=?host_id,
        friendly_name=?host.friendly_name(),
        host_name=?host.hostname(),
        labels=?host.labels(),
        version=?host.version(),
        "Host started");

    let task = tokio::task::spawn(async move {
        let host_subject = host_subject(host_id.as_ref());

        let heartbeat_subject = heartbeat_subject(host_id.as_ref());

        let mut api_subscription = nats_client
            .subscribe(host_subject)
            .await
            .context("failed to subscribe for API requests")?;
        let mut heartbeat_timer = tokio::time::interval(heartbeat_interval);

        loop {
            tokio::select! {
                // Shutdown signal
                _ = &mut one_shot_rx => {
                    api_subscription.unsubscribe().await.context("failed to unsubscribe from API requests")?;
                    return host.stop().await.context("failed to stop host");
                }
                // Send heartbeat
                _ = heartbeat_timer.tick() => {
                    let heartbeat = host_heartbeat(&host).await?;
                    let heartbeat_bytes = serde_json::to_vec(&heartbeat)
                        .context("failed to serialize heartbeat")?;
                    nats_client.publish(heartbeat_subject.clone(), heartbeat_bytes.into()).await.context("failed to publish heartbeat")?;
                }
                // Handle API requests
                Some(msg) = api_subscription.next() => {
                    let response = handle_command(host.as_ref(), &msg, host.config()).await;
                    match response {
                        Ok(resp_bytes) => {
                            if let Some(reply_to) = msg.reply {
                                nats_client.publish(reply_to, resp_bytes.into()).await.context("failed to publish API response")?;
                            }
                        }
                        Err(e) => {
                            eprintln!("Error handling command: {}", e);
                        }
                    }
                }
            }
        }
    });

    Ok(async move {
        let _ = one_shot_tx.send(());
        task.await?
    })
}

/// Configuration options for NATS connections
#[derive(Debug, Clone, Default)]
pub struct NatsConnectionOptions {
    /// Request timeout for NATS operations
    pub request_timeout: Option<Duration>,
    /// Path to TLS CA certificate file for NATS connection
    pub tls_ca: Option<PathBuf>,
    /// Enable TLS handshake first mode for NATS connection
    pub tls_first: bool,
    /// Path to NATS credentials file
    pub credentials: Option<PathBuf>,
}

pub async fn connect_nats(
    addr: impl async_nats::ToServerAddrs,
    options: Option<NatsConnectionOptions>,
) -> Result<async_nats::Client, anyhow::Error> {
    let options = options.unwrap_or_default();

    // Install the default crypto provider for rustls when using TLS options.
    // This must be done before any TLS-related operations.
    // We use ring for consistency with other dependencies in the workspace.
    // It's safe to call multiple times - it will only install once.
    if options.tls_ca.is_some() || options.tls_first {
        let _ = rustls::crypto::ring::default_provider().install_default();
    }

    let mut opts = async_nats::ConnectOptions::new();
    if let Some(timeout) = options.request_timeout {
        opts = opts.request_timeout(Some(timeout));
    }
    if let Some(tls_ca) = options.tls_ca {
        anyhow::ensure!(
            tls_ca.exists(),
            "NATS TLS CA certificate file does not exist: {}",
            tls_ca.display()
        );
        opts = opts.add_root_certificates(tls_ca);
    }
    if options.tls_first {
        opts = opts.tls_first();
    }
    if let Some(credentials) = options.credentials {
        anyhow::ensure!(
            credentials.exists(),
            "NATS credentials file does not exist: {}",
            credentials.display()
        );
        opts = opts
            .credentials_file(&credentials)
            .await
            .context("failed to load NATS credentials")?;
    }
    opts.connect(addr)
        .await
        .context("failed to connect to NATS")
}

pub fn host_subject(host_id: &str) -> String {
    format!("{HOST_API_PREFIX}.{host_id}.>")
}

pub fn rpc_subject(host_id: &str, command: &str) -> String {
    format!("{HOST_API_PREFIX}.{host_id}.{command}")
}

pub fn heartbeat_subject(host_id: &str) -> String {
    format!("{OPERATOR_API_PREFIX}.heartbeat.{host_id}")
}

/// Helper function to serialize a message to the API format.
fn to_api<T: prost::Message + serde::Serialize>(msg: &T) -> Result<Vec<u8>, anyhow::Error> {
    serde_json::to_vec_pretty(msg).map_err(anyhow::Error::new)
}

/// Helper function to deserialize a message from the API format.
fn from_api<'de, T: serde::Deserialize<'de>>(bytes: &'de [u8]) -> Result<T, anyhow::Error> {
    serde_json::from_slice(bytes).map_err(anyhow::Error::new)
}

async fn handle_command(
    host: &impl HostApi,
    msg: &async_nats::Message,
    config: &HostConfig,
) -> Result<Vec<u8>, anyhow::Error> {
    let command = msg.subject.split('.').skip(3).collect::<Vec<_>>().join(".");

    let payload = &msg.payload;

    match command.as_str() {
        "heartbeat" => {
            let res = host_heartbeat(host).await?;
            to_api(&res)
        }
        "workload.start" => {
            let req: types::v2::WorkloadStartRequest = from_api(payload)?;
            let res = workload_start(host, req, config).await?;
            to_api(&res)
        }
        "workload.stop" => {
            let req: types::v2::WorkloadStopRequest = from_api(payload)?;
            let res = workload_stop(host, req).await?;
            to_api(&res)
        }
        "workload.status" => {
            let req: types::v2::WorkloadStatusRequest = from_api(payload)?;
            let res = workload_status(host, req).await?;
            to_api(&res)
        }
        // catch-all
        _ => anyhow::bail!("unknown command: {command}"),
    }
}

/// Convert ImagePullSecret from protobuf to OciConfig
fn image_pull_secret_to_oci_config(
    config: &HostConfig,
    pull_secret: &Option<types::v2::ImagePullSecret>,
) -> oci::OciConfig {
    let mut oci_config = match &pull_secret {
        Some(creds) => oci::OciConfig::new_with_credentials(&creds.username, &creds.password),
        None => OciConfig::default(),
    };
    oci_config.insecure = config.allow_oci_insecure;
    oci_config.timeout = config.oci_pull_timeout;

    oci_config
}

async fn host_heartbeat(host: &impl HostApi) -> anyhow::Result<types::v2::HostHeartbeat> {
    let hb = host.heartbeat().await?;

    Ok(hb.into())
}

async fn workload_start(
    host: &impl HostApi,
    req: types::v2::WorkloadStartRequest,
    config: &HostConfig,
) -> anyhow::Result<types::v2::WorkloadStartResponse> {
    let Some(types::v2::Workload {
        namespace,
        name,
        annotations,
        service,
        wit_world,
        volumes,
    }) = req.workload
    else {
        anyhow::bail!("workload is required");
    };

    let (components, host_interfaces) = if let Some(wit_world) = wit_world {
        let mut pulled_components = Vec::with_capacity(wit_world.components.len());
        for component in &wit_world.components {
            let oci_config = image_pull_secret_to_oci_config(config, &component.image_pull_secret);
            let bytes = match oci::pull_component(&component.image, oci_config).await {
                Ok(bytes) => bytes,
                Err(e) => {
                    return Ok(types::v2::WorkloadStartResponse {
                        workload_status: Some(types::v2::WorkloadStatus {
                            workload_id: "".into(),
                            workload_state: types::v2::WorkloadState::Error.into(),
                            message: format!(
                                "failed to pull component image {}: {}",
                                component.image, e
                            ),
                        }),
                    });
                }
            };
            pulled_components.push(crate::types::Component {
                bytes: bytes.0.into(),
                local_resources: component
                    .local_resources
                    .clone()
                    .map(Into::into)
                    .unwrap_or_default(),
                pool_size: component.pool_size,
                max_invocations: component.max_invocations,
            })
        }
        (
            pulled_components,
            wit_world
                .host_interfaces
                .into_iter()
                .map(Into::into)
                .collect(),
        )
    } else {
        (vec![], vec![])
    };

    let service = if let Some(service) = service {
        let oci_config = image_pull_secret_to_oci_config(config, &service.image_pull_secret);
        let bytes = match oci::pull_component(&service.image, oci_config).await {
            Ok(bytes) => bytes,
            Err(e) => {
                return Ok(types::v2::WorkloadStartResponse {
                    workload_status: Some(types::v2::WorkloadStatus {
                        workload_id: "".into(),
                        workload_state: types::v2::WorkloadState::Error.into(),
                        message: format!("failed to pull service image {}: {}", service.image, e),
                    }),
                });
            }
        };
        Some(crate::types::Service {
            bytes: bytes.0.into(),
            local_resources: service
                .local_resources
                .clone()
                .map(Into::into)
                .unwrap_or_default(),
            max_restarts: service.max_restarts,
        })
    } else {
        None
    };

    let volumes = volumes.into_iter().map(Into::into).collect();

    let request = crate::types::WorkloadStartRequest {
        workload_id: uuid::Uuid::new_v4().to_string(),
        workload: crate::types::Workload {
            namespace,
            name,
            annotations,
            service,
            components,
            host_interfaces,
            volumes,
        },
    };

    info!(
        worload_id=?request.workload_id,
        namespace=?request.workload.namespace,
        name=?request.workload.name,
        "Starting workload");

    Ok(host.workload_start(request).await?.into())
}

async fn workload_stop(
    host: &impl HostApi,
    req: types::v2::WorkloadStopRequest,
) -> anyhow::Result<types::v2::WorkloadStopResponse> {
    info!(
        worload_id=?req.workload_id,
        "Stopping workload");

    host.workload_stop(req.into()).await.map(|resp| resp.into())
}

async fn workload_status(
    host: &impl HostApi,
    req: types::v2::WorkloadStatusRequest,
) -> anyhow::Result<types::v2::WorkloadStatusResponse> {
    debug!(
        worload_id=?req.workload_id,
        "Fetching workload status");

    host.workload_status(req.into())
        .await
        .map(|resp| resp.into())
}

/// Creates a tracing span for a host invocation with relevant attributes.
/// Use when calling components from plugins (component exported interface) to
/// ensure consistent tracing.
pub fn host_invocation_span(
    workload_namespace: impl AsRef<str>,
    workload_name: impl AsRef<str>,
    component_id: impl AsRef<str>,
    plugin_id: impl AsRef<str>,
    plugin_operation: impl AsRef<str>,
) -> tracing::Span {
    tracing::span!(
        tracing::Level::INFO,
        "HostInvocation",
        component_id = component_id.as_ref(),
        workload_namespace = workload_namespace.as_ref(),
        workload_name = workload_name.as_ref(),
        plugin_id = plugin_id.as_ref(),
        plugin_operation = plugin_operation.as_ref(),
    )
}

pub fn resource_builder() -> ResourceBuilder {
    Resource::builder()
        .with_attribute(KeyValue::new(
            resource::SERVICE_NAME.to_string(),
            "wash-host",
        ))
        .with_attribute(KeyValue::new(
            resource::SERVICE_INSTANCE_ID.to_string(),
            uuid::Uuid::new_v4().to_string(),
        ))
        .with_attribute(KeyValue::new(
            resource::SERVICE_VERSION.to_string(),
            env!("CARGO_PKG_VERSION"),
        ))
        .with_attributes(vec![
            KeyValue::new("host.version", env!("CARGO_PKG_VERSION")),
            KeyValue::new("host.hostname", System::host_name().unwrap_or_default()),
            KeyValue::new(
                "host.kernel_version",
                System::kernel_version().unwrap_or_default(),
            ),
            KeyValue::new("host.os_version", System::os_version().unwrap_or_default()),
        ])
}

impl From<types::v2::WitInterface> for crate::wit::WitInterface {
    fn from(wi: types::v2::WitInterface) -> Self {
        crate::wit::WitInterface {
            namespace: wi.namespace,
            package: wi.package,
            version: if wi.version.is_empty() {
                None
            } else {
                wi.version.parse::<semver::Version>().ok()
            },
            interfaces: wi.interfaces.into_iter().collect(),
            config: wi.config,
        }
    }
}
impl From<types::v2::VolumeMount> for crate::types::VolumeMount {
    fn from(vm: types::v2::VolumeMount) -> Self {
        crate::types::VolumeMount {
            name: vm.name,
            mount_path: vm.mount_path,
            read_only: vm.read_only,
        }
    }
}

impl From<types::v2::Volume> for crate::types::Volume {
    fn from(v: types::v2::Volume) -> Self {
        crate::types::Volume {
            name: v.name,
            volume_type: match v.volume_type {
                Some(vt) => match vt {
                    types::v2::volume::VolumeType::HostPath(hp) => {
                        crate::types::VolumeType::HostPath(crate::types::HostPathVolume {
                            local_path: hp.local_path,
                        })
                    }
                    types::v2::volume::VolumeType::EmptyDir(_) => {
                        crate::types::VolumeType::EmptyDir(crate::types::EmptyDirVolume {})
                    }
                },
                None => crate::types::VolumeType::EmptyDir(crate::types::EmptyDirVolume {}),
            },
        }
    }
}

impl From<types::v2::LocalResources> for crate::types::LocalResources {
    fn from(lr: types::v2::LocalResources) -> Self {
        crate::types::LocalResources {
            memory_limit_mb: lr.memory_limit_mb,
            cpu_limit: lr.cpu_limit,
            config: lr.config,
            volume_mounts: lr.volume_mounts.into_iter().map(Into::into).collect(),
            allowed_hosts: lr.allowed_hosts,
            environment: lr.environment,
        }
    }
}

impl From<crate::types::HostHeartbeat> for types::v2::HostHeartbeat {
    fn from(hb: crate::types::HostHeartbeat) -> Self {
        types::v2::HostHeartbeat {
            id: hb.id,
            hostname: hb.hostname,
            version: hb.version,
            started_at: Some(hb.started_at.into()),
            imports: hb.imports.into_iter().map(Into::into).collect(),
            exports: hb.exports.into_iter().map(Into::into).collect(),
            os_name: hb.os_name,
            os_arch: hb.os_arch,
            os_kernel: hb.os_kernel,
            system_cpu_usage: hb.system_cpu_usage,
            component_count: hb.component_count,
            workload_count: hb.workload_count,
            system_memory_total: hb.system_memory_total,
            system_memory_free: hb.system_memory_free,
            labels: hb.labels,
            friendly_name: hb.friendly_name,
        }
    }
}

impl From<crate::wit::WitInterface> for types::v2::WitInterface {
    fn from(wi: crate::wit::WitInterface) -> Self {
        types::v2::WitInterface {
            namespace: wi.namespace,
            package: wi.package,
            version: wi.version.map(|v| v.to_string()).unwrap_or_default(),
            interfaces: wi.interfaces.into_iter().collect(),
            config: wi.config,
        }
    }
}

// Conversions from API v2 request types to runtime::host types

impl From<types::v2::WorkloadStopRequest> for crate::types::WorkloadStopRequest {
    fn from(req: types::v2::WorkloadStopRequest) -> Self {
        crate::types::WorkloadStopRequest {
            workload_id: req.workload_id,
        }
    }
}

impl From<types::v2::WorkloadStatusRequest> for crate::types::WorkloadStatusRequest {
    fn from(req: types::v2::WorkloadStatusRequest) -> Self {
        crate::types::WorkloadStatusRequest {
            workload_id: req.workload_id,
        }
    }
}

// Conversions from runtime::host response types to API v2 types

impl From<crate::types::WorkloadStartResponse> for types::v2::WorkloadStartResponse {
    fn from(resp: crate::types::WorkloadStartResponse) -> Self {
        types::v2::WorkloadStartResponse {
            workload_status: Some(resp.workload_status.into()),
        }
    }
}

impl From<crate::types::WorkloadStopResponse> for types::v2::WorkloadStopResponse {
    fn from(resp: crate::types::WorkloadStopResponse) -> Self {
        types::v2::WorkloadStopResponse {
            workload_status: Some(resp.workload_status.into()),
        }
    }
}

impl From<crate::types::WorkloadStatusResponse> for types::v2::WorkloadStatusResponse {
    fn from(resp: crate::types::WorkloadStatusResponse) -> Self {
        types::v2::WorkloadStatusResponse {
            workload_status: Some(resp.workload_status.into()),
        }
    }
}

impl From<crate::types::WorkloadStatus> for types::v2::WorkloadStatus {
    fn from(status: crate::types::WorkloadStatus) -> Self {
        types::v2::WorkloadStatus {
            workload_id: status.workload_id,
            workload_state: status.workload_state as i32,
            message: status.message,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_image_pull_secret_to_oci_config_none() {
        let host_config = HostConfig {
            allow_oci_insecure: false,
            oci_pull_timeout: None,
        };
        let secret: Option<types::v2::ImagePullSecret> = None;
        let config = image_pull_secret_to_oci_config(&host_config, &secret);
        assert!(config.credentials.is_none());
        assert!(!config.insecure);
    }

    #[tokio::test]
    async fn test_image_pull_secret_to_oci_config_basic_auth() {
        let secret = Some(types::v2::ImagePullSecret {
            username: "testuser".to_string(),
            password: "testpass".to_string(),
        });

        let host_config = HostConfig {
            allow_oci_insecure: false,
            oci_pull_timeout: None,
        };
        let config = image_pull_secret_to_oci_config(&host_config, &secret);
        assert_eq!(
            config.credentials,
            Some(("testuser".to_string(), "testpass".to_string()))
        );
    }
}
